use serde::{Deserialize, Serialize};
use std::collections::HashMap;
use std::path::Path;
use log::{info, debug, warn, error};
use super::models::{AltFile, Task, TaskStatus, Priority};
use super::parser::{AltParser, AltParseError};

/// Represents a task result from execution
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct TaskResult {
    /// ID of the task
    pub task_id: String,
    
    /// Status of the task after execution
    pub status: TaskStatus,
    
    /// Output of the task (if successful)
    pub output: Option<serde_json::Value>,
    
    /// Error message (if failed)
    pub error: Option<String>,
    
    /// Execution time in milliseconds
    pub execution_time_ms: u64,
    
    /// Number of retries performed
    pub retry_count: u8,
    
    /// Artifacts generated by the task
    pub artifacts: Option<Vec<Artifact>>,
    
    /// Additional metadata
    pub metadata: Option<HashMap<String, serde_json::Value>>,
}

/// Represents an artifact generated during task execution
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Artifact {
    /// ID of the artifact
    pub id: String,
    
    /// Type of the artifact (e.g., "image", "text", "audio")
    pub artifact_type: String,
    
    /// MIME type of the artifact
    pub mime_type: String,
    
    /// Size of the artifact in bytes
    pub size_bytes: u64,
    
    /// Path to the artifact file (relative to the LAST file)
    pub path: String,
    
    /// Optional description of the artifact
    pub description: Option<String>,
    
    /// Optional metadata
    pub metadata: Option<HashMap<String, serde_json::Value>>,
}

/// Represents a LAST file (result of executing an ALT file)
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct LastFile {
    /// ID of the LAST file
    pub id: String,
    
    /// ID of the ALT file that was executed
    pub alt_file_id: String,
    
    /// Title of the LAST file
    pub title: String,
    
    /// Description of the LAST file
    pub description: Option<String>,
    
    /// Timestamp when the execution started
    pub execution_started: chrono::DateTime<chrono::Utc>,
    
    /// Timestamp when the execution completed
    pub execution_completed: chrono::DateTime<chrono::Utc>,
    
    /// Mode in which the ALT file was executed
    pub mode: Option<String>,
    
    /// Persona used for execution
    pub persona: Option<String>,
    
    /// Results of task executions
    pub task_results: Vec<TaskResult>,
    
    /// Overall success rate (0.0 to 1.0)
    pub success_rate: f64,
    
    /// Total execution time in milliseconds
    pub total_execution_time_ms: u64,
    
    /// Path to the execution graph visualization (if generated)
    pub execution_graph_path: Option<String>,
    
    /// Additional metadata
    pub metadata: Option<HashMap<String, serde_json::Value>>,
}

impl LastFile {
    /// Creates a new LAST file from an ALT file
    pub fn new(alt_file: &AltFile, title: Option<String>) -> Self {
        let now = chrono::Utc::now();
        
        LastFile {
            id: format!("last_{}", uuid::Uuid::new_v4()),
            alt_file_id: alt_file.id.clone(),
            title: title.unwrap_or_else(|| format!("Result of {}", alt_file.title)),
            description: alt_file.description.clone(),
            execution_started: now,
            execution_completed: now, // Will be updated when execution completes
            mode: alt_file.mode.as_ref().map(|m| format!("{:?}", m).to_lowercase()),
            persona: alt_file.persona.clone(),
            task_results: Vec::new(),
            success_rate: 0.0,
            total_execution_time_ms: 0,
            execution_graph_path: None,
            metadata: alt_file.metadata.clone(),
        }
    }
    
    /// Adds a task result to the LAST file
    pub fn add_task_result(&mut self, result: TaskResult) {
        self.task_results.push(result);
        self.update_success_rate();
    }
    
    /// Updates the success rate based on task results
    fn update_success_rate(&mut self) {
        if self.task_results.is_empty() {
            self.success_rate = 0.0;
            return;
        }
        
        let successful_tasks = self.task_results
            .iter()
            .filter(|r| r.status == TaskStatus::Completed)
            .count();
            
        self.success_rate = successful_tasks as f64 / self.task_results.len() as f64;
    }
    
    /// Completes the LAST file execution
    pub fn complete_execution(&mut self) {
        self.execution_completed = chrono::Utc::now();
        self.total_execution_time_ms = (self.execution_completed - self.execution_started)
            .num_milliseconds()
            .max(0) as u64;
        self.update_success_rate();
    }
    
    /// Gets a task result by task ID
    pub fn get_task_result(&self, task_id: &str) -> Option<&TaskResult> {
        self.task_results.iter().find(|r| r.task_id == task_id)
    }
    
    /// Gets all successful task results
    pub fn get_successful_tasks(&self) -> Vec<&TaskResult> {
        self.task_results
            .iter()
            .filter(|r| r.status == TaskStatus::Completed)
            .collect()
    }
    
    /// Gets all failed task results
    pub fn get_failed_tasks(&self) -> Vec<&TaskResult> {
        self.task_results
            .iter()
            .filter(|r| r.status == TaskStatus::Failed)
            .collect()
    }
    
    /// Gets all artifacts from all tasks
    pub fn get_all_artifacts(&self) -> Vec<&Artifact> {
        self.task_results
            .iter()
            .filter_map(|r| r.artifacts.as_ref())
            .flat_map(|artifacts| artifacts.iter())
            .collect()
    }
    
    /// Generates a summary of the execution
    pub fn generate_summary(&self) -> String {
        let successful = self.get_successful_tasks().len();
        let failed = self.get_failed_tasks().len();
        let total = self.task_results.len();
        let artifacts = self.get_all_artifacts().len();
        
        format!(
            "Execution Summary for '{}'\n\
             ALT File ID: {}\n\
             Execution Time: {} ms\n\
             Success Rate: {:.1}%\n\
             Tasks: {} total, {} successful, {} failed\n\
             Artifacts: {} generated",
            self.title,
            self.alt_file_id,
            self.total_execution_time_ms,
            self.success_rate * 100.0,
            total,
            successful,
            failed,
            artifacts
        )
    }
}

/// Represents a LAST file generator
pub struct LastFileGenerator {
    /// Output directory for LAST files
    output_dir: std::path::PathBuf,
    
    /// Whether to generate execution graphs
    generate_graphs: bool,
    
    /// Whether to compress artifacts
    compress_artifacts: bool,
}

impl LastFileGenerator {
    /// Creates a new LAST file generator
    pub fn new<P: AsRef<Path>>(output_dir: P) -> Self {
        LastFileGenerator {
            output_dir: output_dir.as_ref().to_path_buf(),
            generate_graphs: true,
            compress_artifacts: true,
        }
    }
    
    /// Sets whether to generate execution graphs
    pub fn with_graphs(mut self, generate: bool) -> Self {
        self.generate_graphs = generate;
        self
    }
    
    /// Sets whether to compress artifacts
    pub fn with_compression(mut self, compress: bool) -> Self {
        self.compress_artifacts = compress;
        self
    }
    
    /// Generates a LAST file from an ALT file and task results
    pub fn generate(&self, alt_file: &AltFile, task_results: Vec<TaskResult>) -> Result<LastFile, AltParseError> {
        info!("Generating LAST file for ALT file ID: {}", alt_file.id);
        
        // Create a new LAST file
        let mut last_file = LastFile::new(alt_file, None);
        
        // Add all task results
        for result in task_results {
            last_file.add_task_result(result);
        }
        
        // Complete the execution
        last_file.complete_execution();
        
        // Generate execution graph if enabled
        if self.generate_graphs {
            match self.generate_execution_graph(alt_file, &last_file) {
                Ok(graph_path) => {
                    last_file.execution_graph_path = Some(graph_path);
                }
                Err(e) => {
                    warn!("Failed to generate execution graph: {}", e);
                }
            }
        }
        
        // Save the LAST file
        self.save_last_file(&last_file)?;
        
        info!("Successfully generated LAST file with ID: {}", last_file.id);
        Ok(last_file)
    }
    
    /// Generates an execution graph visualization
    fn generate_execution_graph(&self, alt_file: &AltFile, last_file: &LastFile) -> Result<String, AltParseError> {
        debug!("Generating execution graph for ALT file ID: {}", alt_file.id);
        
        // Create the graphs directory
        let graphs_dir = self.output_dir.join("graphs");
        std::fs::create_dir_all(&graphs_dir)
            .map_err(|e| AltParseError::IoError(e))?;
        
        // Generate a DOT file for GraphViz
        let dot_path = graphs_dir.join(format!("{}.dot", last_file.id));
        let png_path = graphs_dir.join(format!("{}.png", last_file.id));
        let relative_path = format!("graphs/{}.png", last_file.id);
        
        // Create the DOT file content
        let mut dot_content = String::from("digraph execution {\n");
        dot_content.push_str("  rankdir=LR;\n");
        dot_content.push_str("  node [shape=box, style=filled];\n");
        
        // Add nodes for each task
        for task in &alt_file.tasks {
            let result = last_file.get_task_result(&task.id);
            let color = match result {
                Some(r) if r.status == TaskStatus::Completed => "lightgreen",
                Some(r) if r.status == TaskStatus::Failed => "lightcoral",
                Some(r) if r.status == TaskStatus::Running => "lightyellow",
                _ => "lightgray",
            };
            
            let execution_time = result.map(|r| r.execution_time_ms).unwrap_or(0);
            
            dot_content.push_str(&format!(
                "  \"{}\" [label=\"{}\nTime: {}ms\", fillcolor=\"{}\"];\n",
                task.id,
                task.description,
                execution_time,
                color
            ));
            
            // Add edges for dependencies
            if let Some(deps) = &task.dependencies {
                for dep in deps {
                    dot_content.push_str(&format!("  \"{}\" -> \"{}\";\n", dep, task.id));
                }
            }
        }
        
        dot_content.push_str("}\n");
        
        // Write the DOT file
        std::fs::write(&dot_path, dot_content)
            .map_err(|e| AltParseError::IoError(e))?;
        
        // Try to generate PNG using GraphViz (if available)
        let graphviz_result = std::process::Command::new("dot")
            .args(&["-Tpng", "-o"])
            .arg(&png_path)
            .arg(&dot_path)
            .output();
            
        match graphviz_result {
            Ok(output) if output.status.success() => {
                debug!("Successfully generated execution graph at: {:?}", png_path);
                Ok(relative_path)
            }
            Ok(output) => {
                warn!("GraphViz command failed: {}", String::from_utf8_lossy(&output.stderr));
                Err(AltParseError::FormatError("Failed to generate graph with GraphViz".to_string()))
            }
            Err(e) => {
                warn!("Failed to execute GraphViz command: {}", e);
                Err(AltParseError::IoError(e))
            }
        }
    }
    
    /// Saves a LAST file to disk
    fn save_last_file(&self, last_file: &LastFile) -> Result<(), AltParseError> {
        debug!("Saving LAST file with ID: {}", last_file.id);
        
        // Create the output directory
        let last_dir = self.output_dir.join(&last_file.id);
        std::fs::create_dir_all(&last_dir)
            .map_err(|e| AltParseError::IoError(e))?;
        
        // Save the LAST file as JSON
        let last_path = last_dir.join("result.last");
        let json = serde_json::to_string_pretty(last_file)
            .map_err(|e| AltParseError::JsonError(e))?;
            
        std::fs::write(&last_path, json)
            .map_err(|e| AltParseError::IoError(e))?;
        
        // Create an HTML report
        self.generate_html_report(last_file, &last_dir)?;
        
        debug!("Successfully saved LAST file to: {:?}", last_path);
        Ok(())
    }
    
    /// Generates an HTML report for the LAST file
    fn generate_html_report(&self, last_file: &LastFile, output_dir: &Path) -> Result<(), AltParseError> {
        debug!("Generating HTML report for LAST file ID: {}", last_file.id);
        
        // Create a simple HTML report
        let mut html = String::from("<!DOCTYPE html>\n<html>\n<head>\n");
        html.push_str("<meta charset=\"UTF-8\">\n");
        html.push_str("<meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n");
        html.push_str(&format!("<title>Execution Report: {}</title>\n", last_file.title));
        html.push_str("<style>\n");
        html.push_str("body { font-family: Arial, sans-serif; margin: 0; padding: 20px; }\n");
        html.push_str("h1, h2, h3 { color: #333; }\n");
        html.push_str(".container { max-width: 1200px; margin: 0 auto; }\n");
        html.push_str(".summary { background-color: #f5f5f5; padding: 15px; border-radius: 5px; margin-bottom: 20px; }\n");
        html.push_str(".task { border: 1px solid #ddd; padding: 15px; margin-bottom: 10px; border-radius: 5px; }\n");
        html.push_str(".task.success { border-left: 5px solid #4CAF50; }\n");
        html.push_str(".task.failure { border-left: 5px solid #F44336; }\n");
        html.push_str(".task-header { display: flex; justify-content: space-between; margin-bottom: 10px; }\n");
        html.push_str(".artifacts { margin-top: 10px; }\n");
        html.push_str(".artifact { background-color: #f9f9f9; padding: 10px; margin-top: 5px; border-radius: 3px; }\n");
        html.push_str("</style>\n");
        html.push_str("</head>\n<body>\n");
        html.push_str("<div class=\"container\">\n");
        
        // Header
        html.push_str(&format!("<h1>Execution Report: {}</h1>\n", last_file.title));
        
        // Summary
        html.push_str("<div class=\"summary\">\n");
        html.push_str(&format!("<h2>Summary</h2>\n"));
        html.push_str(&format!("<p><strong>ALT File ID:</strong> {}</p>\n", last_file.alt_file_id));
        html.push_str(&format!("<p><strong>Execution Started:</strong> {}</p>\n", last_file.execution_started));
        html.push_str(&format!("<p><strong>Execution Completed:</strong> {}</p>\n", last_file.execution_completed));
        html.push_str(&format!("<p><strong>Total Execution Time:</strong> {} ms</p>\n", last_file.total_execution_time_ms));
        html.push_str(&format!("<p><strong>Success Rate:</strong> {:.1}%</p>\n", last_file.success_rate * 100.0));
        html.push_str(&format!("<p><strong>Tasks:</strong> {} total, {} successful, {} failed</p>\n",
            last_file.task_results.len(),
            last_file.get_successful_tasks().len(),
            last_file.get_failed_tasks().len()
        ));
        
        // Execution Graph
        if let Some(graph_path) = &last_file.execution_graph_path {
            html.push_str(&format!("<p><strong>Execution Graph:</strong> <a href=\"{}\" target=\"_blank\">View Graph</a></p>\n", graph_path));
        }
        
        html.push_str("</div>\n");
        
        // Task Results
        html.push_str("<h2>Task Results</h2>\n");
        
        for result in &last_file.task_results {
            let status_class = if result.status == TaskStatus::Completed { "success" } else { "failure" };
            
            html.push_str(&format!("<div class=\"task {}\">\n", status_class));
            
            // Task Header
            html.push_str("<div class=\"task-header\">\n");
            html.push_str(&format!("<h3>{}</h3>\n", result.task_id));
            html.push_str(&format!("<span><strong>Status:</strong> {:?}</span>\n", result.status));
            html.push_str("</div>\n");
            
            // Task Details
            html.push_str(&format!("<p><strong>Execution Time:</strong> {} ms</p>\n", result.execution_time_ms));
            html.push_str(&format!("<p><strong>Retry Count:</strong> {}</p>\n", result.retry_count));
            
            // Output or Error
            if let Some(output) = &result.output {
                html.push_str("<div><strong>Output:</strong> <pre>");
                html.push_str(&serde_json::to_string_pretty(output).unwrap_or_else(|_| "Error formatting output".to_string()));
                html.push_str("</pre></div>\n");
            }
            
            if let Some(error) = &result.error {
                html.push_str(&format!("<div><strong>Error:</strong> <pre>{}</pre></div>\n", error));
            }
            
            // Artifacts
            if let Some(artifacts) = &result.artifacts {
                html.push_str("<div class=\"artifacts\">\n");
                html.push_str(&format!("<h4>Artifacts ({})</h4>\n", artifacts.len()));
                
                for artifact in artifacts {
                    html.push_str("<div class=\"artifact\">\n");
                    html.push_str(&format!("<p><strong>ID:</strong> {}</p>\n", artifact.id));
                    html.push_str(&format!("<p><strong>Type:</strong> {}</p>\n", artifact.artifact_type));
                    html.push_str(&format!("<p><strong>MIME Type:</strong> {}</p>\n", artifact.mime_type));
                    html.push_str(&format!("<p><strong>Size:</strong> {} bytes</p>\n", artifact.size_bytes));
                    
                    if let Some(desc) = &artifact.description {
                        html.push_str(&format!("<p><strong>Description:</strong> {}</p>\n", desc));
                    }
                    
                    html.push_str(&format!("<p><a href=\"{}\" target=\"_blank\">View Artifact</a></p>\n", artifact.path));
                    html.push_str("</div>\n");
                }
                
                html.push_str("</div>\n");
            }
            
            html.push_str("</div>\n");
        }
        
        html.push_str("</div>\n");
        html.push_str("</body>\n</html>");
        
        // Write the HTML report
        let html_path = output_dir.join("report.html");
        std::fs::write(&html_path, html)
            .map_err(|e| AltParseError::IoError(e))?;
        
        debug!("Successfully generated HTML report at: {:?}", html_path);
        Ok(())
    }
}

/// Creates a sample task result for testing
pub fn create_sample_task_result(task_id: &str, status: TaskStatus) -> TaskResult {
    TaskResult {
        task_id: task_id.to_string(),
        status,
        output: if status == TaskStatus::Completed {
            Some(serde_json::json!({
                "message": "Task completed successfully",
                "data": {
                    "value": 42,
                    "text": "Sample output"
                }
            }))
        } else {
            None
        },
        error: if status == TaskStatus::Failed {
            Some("Task execution failed".to_string())
        } else {
            None
        },
        execution_time_ms: 1500,
        retry_count: 0,
        artifacts: Some(vec![
            Artifact {
                id: format!("artifact_{}", uuid::Uuid::new_v4()),
                artifact_type: "text".to_string(),
                mime_type: "text/plain".to_string(),
                size_bytes: 1024,
                path: format!("artifacts/{}.txt", task_id),
                description: Some("Sample artifact".to_string()),
                metadata: None,
            }
        ]),
        metadata: None,
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use super::super::models::{AltFile, Task};
    use super::super::parser::create_sample_alt_file;
    use tempfile::TempDir;
    
    #[test]
    fn test_create_last_file() {
        let alt_file = create_sample_alt_file();
        let last_file = LastFile::new(&alt_file, None);
        
        assert_eq!(last_file.alt_file_id, alt_file.id);
        assert!(last_file.title.contains(&alt_file.title));
        assert_eq!(last_file.task_results.len(), 0);
        assert_eq!(last_file.success_rate, 0.0);
    }
    
    #[test]
    fn test_add_task_result() {
        let alt_file = create_sample_alt_file();
        let mut last_file = LastFile::new(&alt_file, None);
        
        // Add a successful task result
        let result1 = create_sample_task_result("task1", TaskStatus::Completed);
        last_file.add_task_result(result1);
        
        // Add a failed task result
        let result2 = create_sample_task_result("task2", TaskStatus::Failed);
        last_file.add_task_result(result2);
        
        assert_eq!(last_file.task_results.len(), 2);
        assert_eq!(last_file.success_rate, 0.5); // 1 out of 2 tasks successful
        
        // Check task retrieval
        let task1 = last_file.get_task_result("task1").unwrap();
        assert_eq!(task1.status, TaskStatus::Completed);
        
        let task2 = last_file.get_task_result("task2").unwrap();
        assert_eq!(task2.status, TaskStatus::Failed);
        
        // Check successful/failed task lists
        let successful = last_file.get_successful_tasks();
        assert_eq!(successful.len(), 1);
        assert_eq!(successful[0].task_id, "task1");
        
        let failed = last_file.get_failed_tasks();
        assert_eq!(failed.len(), 1);
        assert_eq!(failed[0].task_id, "task2");
    }
    
    #[test]
    fn test_generate_last_file() {
        let temp_dir = TempDir::new().unwrap();
        let generator = LastFileGenerator::new(temp_dir.path())
            .with_graphs(false); // Disable graphs for testing
        
        let alt_file = create_sample_alt_file();
        
        // Create task results
        let mut results = Vec::new();
        for task in &alt_file.tasks {
            let status = if task.id == "task1" || task.id == "task2" {
                TaskStatus::Completed
            } else {
                TaskStatus::Failed
            };
            
            results.push(create_sample_task_result(&task.id, status));
        }
        
        // Generate LAST file
        let last_file = generator.generate(&alt_file, results).unwrap();
        
        // Check LAST file
        assert_eq!(last_file.alt_file_id, alt_file.id);
        assert_eq!(last_file.task_results.len(), alt_file.tasks.len());
        
        // Check success rate (2 out of 3 tasks successful)
        assert_eq!(last_file.success_rate, 2.0 / 3.0);
        
        // Check that files were created
        let last_dir = temp_dir.path().join(&last_file.id);
        assert!(last_dir.exists());
        
        let json_file = last_dir.join("result.last");
        assert!(json_file.exists());
        
        let html_file = last_dir.join("report.html");
        assert!(html_file.exists());
    }
    
    #[test]
    fn test_generate_summary() {
        let alt_file = create_sample_alt_file();
        let mut last_file = LastFile::new(&alt_file, None);
        
        // Add task results
        last_file.add_task_result(create_sample_task_result("task1", TaskStatus::Completed));
        last_file.add_task_result(create_sample_task_result("task2", TaskStatus::Completed));
        last_file.add_task_result(create_sample_task_result("task3", TaskStatus::Failed));
        
        // Complete execution
        last_file.complete_execution();
        
        // Generate summary
        let summary = last_file.generate_summary();
        
        // Check summary content
        assert!(summary.contains(&alt_file.id));
        assert!(summary.contains("Success Rate: 66.7%"));
        assert!(summary.contains("Tasks: 3 total, 2 successful, 1 failed"));
        assert!(summary.contains("Artifacts: 3 generated"));
    }
}
